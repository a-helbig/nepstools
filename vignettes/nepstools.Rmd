---
title: "nepstools"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{nepstools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction
The nepstools package provides convenient functions to work with NEPS Scientific Use Files (SUFs). It is inspired by the stata ado nepstools developed by the Forschungsdatenzentrum at LifBi in Bamberg. 

This vignette introduces key functionalities for:

- Reading NEPS data files with `read_neps()`
- Replacing NEPS-specific missing codes with NA with `replace_values_with_na()`
- Recoding season codes to corresponding calendar months with `replace_season_codes()`
- Expanding episode data by episode duration with `expand()`
- Extracting variable question texts with `question()`
- Search for keywords in the attributes of the variables with `lookfor_meta()`

Note that there is a NEPS semantic data file included in this package that only contains meta information and one row of NA values (these files are publicly available on the neps-data website and are therefore allowed to be in this package). This vignette occasionally includes artificial data added to the file to illustrate the package's features.

## 1. Reading NEPS data 
The core of this package is the `read_neps()` function. It reads data from a NEPS Scientific Use File in **dta-format** and attaches associated metadata such as labels, question texts, and harmonization rules as attributes of the variables in the dataframe. Moreover, it allows a language switch of labels and meta information from German to English. 

Under the hood, the function relies on `read_dta()` from the tidyverse package *haven*, which is very performant with larger datasets compared to other dta-readers. It does however not support reading (all) attached meta information in the NEPS-SUF-Files.
For this task the function `read.dta13()` from the package *readstata13* is utilized. Since it does not have to read the rows of the dataset to get access to the meta information, performance with large datasets isnt an issue.

With the arguments *col_select* and *row_select* you can specify the columns and rows that the function will read from the dataset. By default it will read all columns and rows.
```{r }
library(nepstools)

# file path to NEPS semantic file on gaps in lifecourse that is included in this package
path <- system.file("extdata", "SC6_spGap_S_15-0-0.dta", package = "nepstools")

# read data with all cols and rows
df_neps <- read_neps(path)
# print number of cols and rows
print(ncol(df_neps))
print(nrow(df_neps))
# print head of df
head(df_neps)

# read data with variables ID_t and wave only and with 0 rows 
df_neps <- read_neps(path, col_select = c("ID_t", "wave"), row_select = 0)
# print number of cols and rows
print(ncol(df_neps))
print(nrow(df_neps))
# print head of df
head(df_neps)
```

When argument *english* is set to TRUE, all variable and value labels as well as attached meta information will be switched from German (default) to English:
```{r }
library(nepstools)

# file path to NEPS semantic file on gaps in lifecourse that is included in this package
path <- system.file("extdata", "SC6_spGap_S_15-0-0.dta", package = "nepstools")

# read data with english labels and meta
df_neps <- read_neps(path, english = TRUE)
# access variable label, value label and questiontext attribute of a variable
attr(df_neps$ts2912m, "label")
attr(df_neps$ts2912m, "labels")
attr(df_neps$ts2912m, "NEPS_questiontext")

# read data with german labels and meta
df_neps <- read_neps(path, english = FALSE)
# access variable label, value label and questiontext attribute of a variable
attr(df_neps$ts2912m, "label")
attr(df_neps$ts2912m, "labels")
attr(df_neps$ts2912m, "NEPS_questiontext")
```

When argument *compact_meta* is set to TRUE (default), only the following meta infos will be attached if available: questiontext, interview-instruction-text, harmonization rule and alias. If set to FALSE, all available meta infos will be attached.

```{r }
# read data with minimum available meta info
df_neps <- read_neps(path, compact_meta = TRUE)
# show how many attributes are being attached to the data
length(attributes(df_neps$ts2912m))

# read data with all available meta info
df_neps <- read_neps(path, compact_meta = FALSE)
# show how many attributes are being attached to the data
length(attributes(df_neps$ts2912m))
```

When the argument *charren* is set to TRUE, variable names are replaced with instrument names where available. These instrument names may be more intuitive for some NEPS data users, as they are often more self-explanatory.

```{r read_neps}
# read data with minimum available meta info
df_neps <- read_neps(path, charren = TRUE)
# print names of dataset
print(df_neps)

# read data with all available meta infos
df_neps <- read_neps(path, charren = FALSE)
# print names of dataset
print(df_neps)
```

## 2. Replacing NEPS missing values with NA
NEPS datasets use various negative codes to indicate different types of missing values. The `replace_values_with_na()` function replaces these codes by NA for easier handling in R.
```{r replace_values_with_na}
# read data with variables: "ID" and "enddate of episode"
df_neps <- read_neps(path, col_select = c("ID_t", "ts2912m"), row_select = 0) 

# create some artificial datapoints 
artificial_datapoints <- data.frame(
  ID_t = c(1, 2, 3, 4, 5),
  ts2912m = c(-97, 12, NA, 4, -98)
)

# add these artificial datapoints to the empty neps dataset
df_neps <- rbind(df_neps, artificial_datapoints)
print(df_neps)

# now use the replace_values_with_na function
df_clean <- replace_values_with_na(df_neps)
print(df_clean)
```

If you do want all variables to be considered in the function, you can specify variables in the *vars* argument. In addition you can provide custom missing value codes to be considered with the argument *values_to_replace*. Note, that the function also works on vectors.

## 3. Recoding season codes to corresponding months
In the NEPS study, respondents can answer questions on the date of events with seasons instead of exact months. The codes for these seasons are 21,24,27,30 and 32 and correspond to January (1 + 20), April (4 + 20) and so on. 
Use the function `replace_season_codes()` to revert these season codes to standard month codes. 

```{r replace_season_codes}
# read data with variables: "ID" and "enddate of episode"
df_neps <- read_neps(path, col_select = c("ID_t", "ts2912m"), row_select = 0)

# create some artificial datapoints 
artificial_datapoints <- data.frame(
  ID_t = c(1, 2, 3, 4, 5),
  ts2912m = c(24, 12, 32, 4, -98)
)

# add these artificial datapoints to the empty neps dataset
df_neps <- rbind(df_neps, artificial_datapoints)
print(df_neps)

df_month_recoded <- replace_season_codes(df_neps)
print(df_month_recoded)
```

Note that if the *vars* argument is NULL (the default), only variables with label attributes containing "month" or "monat" are processed. Alternatively, you can explicitly specify which variables to include.

## 4. Expanding episode data by duration
Often, episodes or spells are recorded with durations in months or years. The `expand()` function replicates rows according to the length of a specified duration variable. This function is inspired by statas expand function.

```{r expand}
# read data with variables: "ID" and "enddate of episode"
df_neps <- read_neps(path, col_select = c("ID_t", "ts2911m", "ts2911y", "ts2912m", "ts2912y"), row_select = 0)

# create some artificial datapoints 
artificial_datapoints <- data.frame(
  ID_t = c(1, 1, 2, 2, 3),
  sptype = c(24,26,25,26,27),
  ts2911m = c(2, 5, 11, 3, 12),
  ts2911y = c(2008, 2008, 2005, 2006, 2010),
  ts2912m = c(4, 8, 2, 5, 1),
  ts2912y = c(2008, 2008, 2006, 2006, 2011)
)

# add these artificial datapoints to the empty neps dataset
df_neps <- rbind(df_neps, artificial_datapoints)

# generate date and duration variables
df_neps <- df_neps |> 
  dplyr::mutate(start = ((ts2911y-1960)*12)+ts2911m - 1, # months since january 1960
                end = ((ts2912y-1960)*12)+ts2912m - 1, # months since january 1960
                duration = (end - start) + 1) # + 1 required so we dont get episode durations of 0 months

print(df_neps)

# expand the dataframe
expanded_df <- nepstools::expand(df_neps, duration)
print(expanded_df)

# create month indicator - May use a package like lubridate to get a nicer formating for date variables.
expanded_df <- expanded_df |> 
  dplyr::group_by(ID_t) |> 
  dplyr::mutate(month = dplyr::first(start) + dplyr::row_number() - 1)
print(expanded_df)
```

## 5. Extracting question texts
NEPS variables come with attached metadata, including question texts in German or English. Use the convenient wrapper `question()` to print the question text for a specified variable. The language will depend on the argument english (TRUE or FALSE) in the `read_neps()` function.

```{r question}
# read data with variables: "ID" and "enddate of episode"
df_neps <- read_neps(path, col_select = c("ID_t", "ts2912m"))

question(df_neps, "ts2912m")
```


## 6. Search for keywords in attributes of dataframe columns (meta info)
The function `lookfor_meta()` searches in all attached attributes of each variable in a dataframe loaded with `read_neps()` for specified keywords. It is case insensitive by default.

```{r lookfor_meta}
# read data with variables: "ID" and "enddate of episode"
df_neps <- read_neps(path, english = TRUE)

# Search for keyword "type" to identify all variables dealing with the type of the gap episode in one way or another
lookfor_meta(df_neps, "type")

# Search for keyword "retirement" to identify all variables dealing with the type of the gap episode in one way or another
lookfor_meta(df_neps, "retirement")
```

